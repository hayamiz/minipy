#ifndef SYTAX_TREE_HPP
#define SYTAX_TREE_HPP

/* 構文木 */

#include <string>
#include <vector>
#include <iostream>
#include "tokenizer.hpp"
#include "symbol.hpp"

using namespace std;

/* ソース位置を表すデータ構造.
   プログラム実行中, エラーがおきた場所を表示するために
   構文木を表すデータ構造に逐一付随させる
*/
class SrcPos {
public:
    SrcPos(){};
    SrcPos(string filename, int line_no, int column_no){
        this->filename = filename;
        this->line_no = line_no;
        this->column_no = column_no;
    }
    string filename;
    int line_no;
    int column_no;
};

/* ------------------- 式 (expression) ------------------- */

/*「式」の種類をあらわす定数たち:

var           : 変数．例: x + y に出てくる x や yなど
literal_int   : 整数リテラル．例: 15, 38 など
literal_float : 浮動小数点数リテラル．例: 15.3, 38.5 など
literal_string: 文字列リテラル．例: "abc", "def" など
literal_none  : None
display_tuple : タプル．例 (1, 2, 3), (4, x, f(y)) など
display_list  : リスト．例 [1, 2, 3], [4, x, (f(y), z) ] など
display_dict  : 辞書．例 { 1 : 2, 2 : 3, 3 : 4 } など

 */

typedef enum {
  expr_kind_var,		/* 変数 */
  expr_kind_literal_int,	/* 整数リテラル */
  expr_kind_literal_float,	/* 浮動小数点リテラル */
  expr_kind_literal_string,	/* 文字列リテラル */
  expr_kind_none,		/* None */
  expr_kind_display_tuple,	/* タプルを作る ( a, b, c,... ) */
  expr_kind_display_list,	/* リストを作る [ a, b, c,...] */
  expr_kind_display_dict,	/* 辞書を作る   { a : x, b : y } */
  expr_kind_paren,		/* 式を括弧でくくったもの ( e ) */
  expr_kind_operator,		/* あらゆる演算子(+, -, ...)*/
  expr_kind_attref,		/* e.f (下を見よ) */
  expr_kind_subscript,		/* e[e] (辞書，リスト，タプル，文字列の
				   要素をアクセスする 
				   a[x], b[3], b[3][2] etc.) */
  expr_kind_call,		/* 関数呼び出し
				   e(e,e,..) */
  expr_kind_list                /* 式のリスト
                                   return foo, bar, baz の foo, bar, baz の部分 */
} expr_kind_t;

typedef enum {
  fix_kind_prefix,
  fix_kind_infix
} fix_kind_t;

class Expr;
class ExprOperator;
class ExprAttref;
class ExprCall;

/* 式全体は以下のような, 種類をあらわすfield (kind)と, それに応じた
   fieldの union */
class Expr {
    Expr(expr_kind_t k, SrcPos p)
        : kind(k), pos(p) {};

public:
     Expr(){};
    expr_kind_t kind;		/* 式の種類 */
    SrcPos pos;
    
    union {
        symbol_t var;			/* var */
        int lit_i;			/* int literal */
        double lit_f;		/* float literal */
        symbol_t lit_s;		/* string literal */
        Expr * paren;		/* parened */
        vector<Expr> * disp;		/* list/tuple/dict display */
        ExprOperator * op;		/* operator */
        ExprAttref * atr;		/* attribute ref */
        vector<Expr> * sub;		/* subscript */
        ExprCall * call;		/* call */
        vector<Expr> * list;            /* expression list with comma */
    } u;

    // generated by generator.el
    static Expr make_var(string var, SrcPos p);
    static Expr make_literal_int(int literal_int, SrcPos p);
    static Expr make_literal_float(double literal_float, SrcPos p);
    static Expr make_literal_string(string literal_string, SrcPos p);
    static Expr make_none(SrcPos p);
    static Expr make_display_tuple(vector<Expr> display_tuple, SrcPos p);
    static Expr make_display_list(vector<Expr> display_list, SrcPos p);
    static Expr make_display_dict(vector<Expr> display_dict, SrcPos p);
    static Expr make_list(vector<Expr> list, SrcPos p);
    static Expr make_paren(Expr paren, SrcPos p);
    static Expr make_infix_operator(token_kind_t op, Expr a, Expr b, SrcPos p);
    static Expr make_prefix_operator(token_kind_t op, Expr a, SrcPos p);
    static Expr make_attref(Expr a, string f, SrcPos p);
    static Expr make_subscript(Expr a, Expr i, SrcPos p);
    static Expr make_call(Expr f, vector<Expr> args, SrcPos p);

};

/* 演算子には prefix : 演算子がオペランドの前に置かれるもの
              infix : 演算子が2個のオペランドの間に置かれるもの 
   がある．
   prefix :  - x など
   infix :   a - b など

- は prefixでもinfixとも使えるのでそれを区別する
*/

/* 演算式 (a + b, - x, etc.) */
class ExprOperator {
public:
    token_kind_t kind;		/* 演算子の種類 */
    fix_kind_t fix;		/* prefix or infix
				   (unaryの+/-とbinaryの+/-の区別) */
    vector<Expr> args;		/* オペランド */

    ExprOperator(token_kind_t k, fix_kind_t f, vector<Expr> a)
        : kind(k), fix(f), args(a) {};

};

/* expr_attr: 
   a.f みたいな式．例：

   L = [1, 2, 3]
   L.append(4)
   ^^^^^^^^これ

   mini-Pythonではこれは以下の形()でのみ使う

   e0.f(e1, e2, ...)

つまり L.f 単独での使用はせず，必ず関数呼び出しの形でのみ現れることと
する．そして，上のような式は形式的に

   f(e0, e1, e2, ...)

と同値とみなす．

つまり，
   L.append(4) は append(L, 4)ということ
 */
class ExprAttref {
public:
    Expr a;
    symbol_t f;

    ExprAttref(Expr expr, symbol_t str)
        : a(expr), f(str) {};
};

/* expr_call: 
   関数呼び出し f(x, y, z) */
class ExprCall {
public:
    Expr f;			/* 関数 */
    vector<Expr> args;		/* 引数 */

    ExprCall(Expr expr, vector<Expr> ls)
        : f(expr), args(ls) {};
};





/* ------------------- 文 (statement) ------------------- */

/* 文の種類 */
typedef enum {
  stm_kind_expression,		/* 式文．式を書くとそれが文になる．
				   例：  f(x) */
  stm_kind_assignment,		/* 代入.  a = x, a[x] = b, etc. */
  stm_kind_del,		/* del.   del a[x] */
  stm_kind_pass,		/* pass */
  stm_kind_return,		/* return */
  stm_kind_break,		/* break */
  stm_kind_continue,		/* continue */
  stm_kind_print,		/* print */
  stm_kind_global,		/* global Xは変数Xがglobal変数である
				   という宣言 */
  stm_kind_if,			/* if文 */
  stm_kind_while,		/* while文 */
  stm_kind_for,		/* for文 */
  stm_kind_fundef,		/* def文．これも実は文の一種 */
} stm_kind_t;

class Stm;
class StmAssign;
class StmIfBranch;
class StmWhile;
class StmFor;
class StmFunDef;

/* definition of statements */
class Stm {
private:
    Stm(stm_kind_t k, SrcPos p)
        : kind(k), pos(p) {};
public:
    Stm(){};
    
    stm_kind_t kind;
    SrcPos pos;
    union {
        Expr * e;			/* expression, return, print statement, del */
        StmAssign * a;
        vector<StmIfBranch> * i;
        StmWhile * w;
        StmFor * f;
        StmFunDef * d;
        string * g;			/* global x */
    } u;

    static Stm make_expression(Expr e, SrcPos pos);
    static Stm make_assignment(Expr t, Expr v, SrcPos pos);
    static Stm make_pass(SrcPos pos);
    static Stm make_return(Expr e, SrcPos pos);
    static Stm make_break(SrcPos pos);
    static Stm make_continue(SrcPos pos);
    static Stm make_print(Expr e, SrcPos pos);
    static Stm make_del(Expr e, SrcPos pos);
    static Stm make_global(string g, SrcPos pos);
    static Stm make_if(vector<StmIfBranch> brs, SrcPos pos);
    static Stm make_while(Expr e, vector<Stm> b, SrcPos pos);
    static Stm make_for(string x, Expr e, vector<Stm> b, SrcPos pos);
    static Stm make_fundef(string f, vector<string> p, vector<Stm> b, SrcPos pos);
};


/* series of sub structures for various statements */
/* 代入文 */
class StmAssign {
public:
    Expr target;
    Expr val;

    StmAssign(Expr t, Expr v)
        : target(t), val(v){};
};


/* ifの中に現れる一つの枝
   
   if x:
   S
   elif y:
   T

   の中の xとSの組やyとTの組．

   else:
   U

   は，e == 0 としてあらわす
*/
class StmIfBranch {
public:
    Expr e;
    vector<Stm> s;
    bool elsep;

    StmIfBranch(vector<Stm> ls)
        : e(), s(ls){
        elsep = true;
    }
    
    StmIfBranch(Expr expr, vector<Stm> ls)
        : e(expr), s(ls){
        elsep = false;
    };
};


/* while文 */
class StmWhile{ /* while e: b */
public: 
    Expr e;			
    vector<Stm> b;

    StmWhile(Expr expr, vector<Stm> ls)
        : e(expr), b(ls) {};
};

/* for文 */
class StmFor{/* for x in e: s */
public:
    symbol_t x;
    Expr e;
    vector<Stm> b;			/* body */

    StmFor(symbol_t str, Expr expr, vector<Stm> ls)
        : x(str), e(expr), b(ls) {};
};

/* def文 */
class StmFunDef {
public:
    symbol_t f;			/* f (p1, ..., pn) b */
    vector<symbol_t> ps;
    vector<Stm> b;

    StmFunDef(symbol_t str, vector<symbol_t> strls, vector<Stm> stmls)
        : f(str), ps(strls), b(stmls) {};
};


#endif
